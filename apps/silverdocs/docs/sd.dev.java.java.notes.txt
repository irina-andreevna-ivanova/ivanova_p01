Java Notes ------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------

___________________________________________________________________________________________________________________________________________________________________________________________________________________________________
Memory allocation
-----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------

Stack - the place where method names, local variables, intermediate computations and return values (if any)
        are kept. The stack contains stack frames. Upon each invocation, the JVM pushes another frame
        in the stack. Upon return from a method, the JVM pops the frame from the stack.
      - member variables
      - each thread has its own stack instance
      - stack is thread safe
      
      -Xss512k -> control the size of the stack
      
Heap  - the place where the instance variables and the object data are kept. To allocate the memory for
        the heap, use -Xmn, -Xms, -Xmx
      - local variables
      - all threads share the same heap
      - heap is not thread safe
      
Setting Java heap for various apps: 
http://javahowto.blogspot.com/2006/06/6-common-errors-in-setting-java-heap.html

___________________________________________________________________________________________________________________________________________________________________________________________________________________________________
Collections
-----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------

Collection (a sequence of individual elements, enforced with some specific rules)
    - Abstract Collection
           - Set (stores only distinctive items, no duplications)
                    o CHILDREN
                        - HashSet: uses hashCode() for storing, very fast for retrieval, no keeping of insertion order
                        - LinkedHashSet: uses hashCode(), keeps the objects in the order of insertion (apparently)
                        - TreeSet
                            o keeps the objects in ascending comparison order (needs Comparator / Comparable items)
                            o uses red-black trees
                        - SortedSet
           - List
                    o CHILDREN
                        - ArrayList: simple non-sync impl of List, uses internally an array to store the objects. Good for random access, bad for multiple inserts and removals
                        - LinkedList: simple non-sync impl of List, uses internally a linked list. Bad for random access, good for multiple inserts and removals
                            o provides more methods than ArrayList, some of them being just diplicates of existing method, but with names more appropriate for the various usage contexts
                        - Stack (can be modeled with LinkedList) 
                    o list behaviour changes according to the equals() method
                    o col.set()
                    o col.retainAll()
                    o col.removeAll()
                    o col.subList()
                    o col.toArray()
                    o col.iterator() => Iterators
                    o list.listIterator(): creates list iterators (ListIterator), that can move bidirectional (it.next(), it.previous(), it.set())
                    o String.CASE_INSENSITIVE_ORDER (Comparator)
           - Queue
                    o CHILDREN
                        - LinkedList (implements the Queue interface)
                        - PriorityQueue: implementation of apriority queue
                        - BlockingQueue
                    o queue.offer()
                    o queue.peek() (returns null, if no elem) - no removal
                    o queue.element() (throws NoSuchElementException, if no elem) - no removal
                    o queue.poll() (returns null, if no elem) - removal
                    o queue.remove() (throws NoSuchElementException, if no elem) - removal
Map (a group of key-value pairs, that allows you to look up an object by a given key (another object))
           - CHILDREN
                - HashMap: very fast, uses hashCode() for storage, no order kept
                - LinkedHashMap: very fast, uses hashCode(), keeps the order of insertion
                - TreeMap: keeps an ascending comparison order (needs Comparator / Comparable items)
                - SortedMap
                - ConcurrentMap
                    - ConcurrentHashMap
           - map.containsKey()
           - map.containsValue()
           - map.putAll()
           - map produces set of keys, collection of values and set of key-value pairs
           
- Arrays.toString() (for arrays; the containers print themselves just fine)
- Arrays.asList ([]) (a,b,c,...) -> unmodifiable list
- Arrays.<Snow>asList( .... )
- Collections.addAll() (preferred approach, instead of new XCollection(Arrays.asList(...))
- Collections.sort()
- Collections.shuffle()           
- Collections.REVERSE_ORDER (same as Collections.reverseOrder())
- Collections.fill() (just duplicates a reference for the entire list)
- Collections.nCopies() (just duplicates a reference N times)
- Iterable (to use in foreach)
- RandomAccess (single implementation: ArrayList)

Deprecated classes (do not use them):
    - Vector
    - Stack
    - Hashtable



---------------

Generators:
- problem with collections: you need to implement your own generators, since Collections.fill(), Collections.nCopies() populates the list with the SAME instance
- use Abstract classes in order to implement your own custom Collections or Maps
- one good idea is to use Flyweight for creating generation-collections or maps: fake the actual list content, storing the index instead of the actual element in the list, or compute
  the item to return only when the item is requested

- optional operations and unsupported operations (such as operations on fixed-size lists)
- Collections.unmodifiableList()  
- Collections.unmodifiableSet()  
- Collections.unmodifiableMap()  
- Collections.unmodifiableSortedSet()  
- Collections.unmodifiableSortedMap()  

List
    - LinkedList.listIterator()
    
Set
        - objects added to Set must at least implement equals()
        - HashSet: optimized for fast lookup. Object must implement hashCode(). Does not guarantee any order.
        - TreeSet: guarantees a particular order, ascending. The objects must implement Comparable, or a Comparator needs to be provided
        - LinkedHashSet: guarantees the insertion order. Uses internally a linked list to keep the insertion order. Objects should implement hashCode()
        - equals() and hashCode() should be overidded in group
    - SortedSet
        - methods: first(), last(), subSet(), headSet(), tailSet()
        
Queue
    - PriorityQueue
    - LinkedList
     
Dequeue
        - double-ended queue
        - add and remove elements from either end
        - putFirst, putLast, offerFirst, offerLast, ....
    - LinkedList
    
Map
        - the keys must implement equals(), hashCode(), Comparable (depending on the selected Map implementation)
    - HashMap
    - TreeMap
    - LinkedHashMap
    - WeakHashMap
    - ConcurrentHashMap
    - IdentityHashMap


___________________________________________________________________________________________________________________________________________________________________________________________________________________________________
Using java.net Authenticator
-----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------

Authenticator.setDefault(new MyAuthenticator("user","password"));
URL url = new URL("http://localhost:5300/database?_query='for $a in collection('test')/types return $a'");
InputStream resultStream = url.openStream();

class MyAuthenticator extends Authenticator {
  private String username, password;

  public MyAuthenticator(String username, String password) {
      this.username = username;
      this.password = password;
  }

  // This method is called when a password-protected URL is accessed
  protected PasswordAuthentication getPasswordAuthentication() {
      return new PasswordAuthentication(username, password.toCharArray());
  }
}